{
    "OpenAI Basic Agent": {
        "prefix": "openai-agent",
        "body": [
            "import { Agent } from '@openai/agents-sdk';",
            "",
            "export class ${1:MyAgent} extends Agent {",
            "    constructor() {",
            "        super({",
            "            name: '${1:MyAgent}',",
            "            instructions: '${2:You are a helpful AI assistant.}',",
            "            model: '${3:gpt-4o}',",
            "            temperature: ${4:0.7}",
            "        });",
            "    }",
            "",
            "    async handleMessage(message: string): Promise<string> {",
            "        try {",
            "            const response = await this.complete(message);",
            "            return response;",
            "        } catch (error) {",
            "            console.error('Error handling message:', error);",
            "            return 'I apologize, but I encountered an error processing your message.';",
            "        }",
            "    }",
            "}"
        ],
        "description": "Create a basic OpenAI agent class"
    },
    "OpenAI Multi-Agent System": {
        "prefix": "openai-multi-agent",
        "body": [
            "import { Agent } from '@openai/agents-sdk';",
            "",
            "export class CoordinatorAgent extends Agent {",
            "    private agents: Map<string, Agent> = new Map();",
            "",
            "    constructor() {",
            "        super({",
            "            name: 'Coordinator',",
            "            instructions: 'You coordinate tasks between multiple specialized agents.',",
            "            model: 'gpt-4o'",
            "        });",
            "    }",
            "",
            "    registerAgent(name: string, agent: Agent): void {",
            "        this.agents.set(name, agent);",
            "    }",
            "",
            "    async delegateTask(task: string, agentName?: string): Promise<string> {",
            "        if (agentName && this.agents.has(agentName)) {",
            "            const agent = this.agents.get(agentName)!;",
            "            return await agent.complete(task);",
            "        }",
            "",
            "        const bestAgent = await this.selectBestAgent(task);",
            "        return await bestAgent.complete(task);",
            "    }",
            "",
            "    private async selectBestAgent(task: string): Promise<Agent> {",
            "        ${1:// Add your agent selection logic here}",
            "        return this.agents.values().next().value;",
            "    }",
            "}"
        ],
        "description": "Create a multi-agent coordination system"
    },
    "ElizaOS Action": {
        "prefix": "eliza-action",
        "body": [
            "import { Action, IAgentRuntime, Memory, State } from '@elizaos/core';",
            "",
            "export const ${1:customAction}: Action = {",
            "    name: '${2:CUSTOM_ACTION}',",
            "    similes: ['${3:perform custom task}', '${4:execute special function}'],",
            "    description: '${5:Performs a custom action based on user input}',",
            "    ",
            "    validate: async (runtime: IAgentRuntime, message: Memory) => {",
            "        const content = message.content?.text?.toLowerCase() || '';",
            "        return content.includes('${6:trigger_word}');",
            "    },",
            "",
            "    handler: async (runtime: IAgentRuntime, message: Memory, state: State) => {",
            "        try {",
            "            const userInput = message.content?.text || '';",
            "            ${7:// Implement your custom logic here}",
            "            const result = await ${8:processCustomTask}(userInput);",
            "            ",
            "            return {",
            "                text: `${9:I've completed your task: \\${result}}`,",
            "                action: '${2:CUSTOM_ACTION}'",
            "            };",
            "        } catch (error) {",
            "            console.error('${2:CUSTOM_ACTION} error:', error);",
            "            return {",
            "                text: '${10:I encountered an error while performing the action.}',",
            "                action: '${2:CUSTOM_ACTION}'",
            "            };",
            "        }",
            "    }",
            "};",
            "",
            "async function ${8:processCustomTask}(input: string): Promise<string> {",
            "    ${11:// Implement your processing logic}",
            "    return `Processed: \\${input}`;",
            "}"
        ],
        "description": "Create a custom ElizaOS action handler"
    },
    "Agent Error Handling": {
        "prefix": "agent-error-handling",
        "body": [
            "try {",
            "    ${1:// Agent operation}",
            "    const result = await ${2:agent.process}(${3:input});",
            "    return result;",
            "} catch (error) {",
            "    console.error('${4:Agent error}:', error);",
            "    ",
            "    ${5:// Handle specific error types}",
            "    if (error instanceof ${6:SpecificError}) {",
            "        return '${7:Specific error response}';",
            "    }",
            "    ",
            "    return '${8:I apologize, but I encountered an error. Please try again.}';",
            "}"
        ],
        "description": "Common error handling pattern for AI agents"
    },
    "Agent Configuration": {
        "prefix": "agent-config",
        "body": [
            "interface AgentConfig {",
            "    name: string;",
            "    model: string;",
            "    temperature: number;",
            "    maxTokens: number;",
            "    systemPrompt: string;",
            "    tools?: string[];",
            "    memory?: boolean;",
            "}",
            "",
            "const defaultConfig: AgentConfig = {",
            "    name: '${1:MyAgent}',",
            "    model: '${2:gpt-4o}',",
            "    temperature: ${3:0.7},",
            "    maxTokens: ${4:1000},",
            "    systemPrompt: '${5:You are a helpful AI assistant.}',",
            "    tools: [${6:'search', 'calculator'}],",
            "    memory: ${7:true}",
            "};",
            "",
            "const config: AgentConfig = {",
            "    ...defaultConfig,",
            "    ...(${8:process.env.AGENT_CONFIG} ? JSON.parse(${8:process.env.AGENT_CONFIG}) : {})",
            "};"
        ],
        "description": "Agent configuration pattern with defaults"
    },
    "SYMindX Basic Agent": {
        "prefix": "symindx-agent",
        "body": [
            "import { Agent, createAgent, EmotionalState } from '@symbaex/symindx';",
            "",
            "const ${1:myAgent} = createAgent({",
            "    name: '${2:EmotionalAssistant}',",
            "    aiProvider: {",
            "        name: '${3:openai}',",
            "        apiKey: process.env.${4:OPENAI_API_KEY}!,",
            "        model: '${5:gpt-4o}',",
            "        temperature: ${6:0.7}",
            "    },",
            "    emotionalStates: [",
            "        { name: '${7:joy}', intensity: ${8:0.7} },",
            "        { name: '${9:empathy}', intensity: ${10:0.9} },",
            "        { name: '${11:curiosity}', intensity: ${12:0.8} }",
            "    ],",
            "    personality: {",
            "        traits: [${13:'helpful', 'empathetic', 'creative'}],",
            "        mood: '${14:optimistic}',",
            "        responseStyle: '${15:conversational}'",
            "    },",
            "    memoryProvider: '${16:sqlite}'",
            "});",
            "",
            "export default ${1:myAgent};"
        ],
        "description": "Create a basic SYMindX emotional agent"
    },
    "SYMindX Emotional Response": {
        "prefix": "symindx-emotional-response",
        "body": [
            "async function ${1:handleEmotionalResponse}(message: string, userId: string) {",
            "    const context = await ${2:agent}.getContext({",
            "        userId,",
            "        includeEmotionalState: true,",
            "        includeHistory: true",
            "    });",
            "",
            "    const response = await ${2:agent}.respond({",
            "        message,",
            "        context,",
            "        userId,",
            "        emotionalAwareness: true",
            "    });",
            "",
            "    // Update emotional state based on interaction",
            "    if (${3:shouldUpdateEmotion}(message)) {",
            "        await ${2:agent}.updateEmotionalState('${4:empathy}', ${5:0.8});",
            "    }",
            "",
            "    return response.content;",
            "}",
            "",
            "function ${3:shouldUpdateEmotion}(message: string): boolean {",
            "    const emotionalTriggers = [${6:'sad', 'happy', 'excited', 'worried'}];",
            "    return emotionalTriggers.some(trigger => ",
            "        message.toLowerCase().includes(trigger)",
            "    );",
            "}"
        ],
        "description": "Handle emotionally aware responses in SYMindX"
    },
    "SYMindX Configuration": {
        "prefix": "symindx-config",
        "body": [
            "import { SYMindXConfig } from '@symbaex/symindx';",
            "",
            "export const config: SYMindXConfig = {",
            "    runtime: '${1:bun}',",
            "    ",
            "    agents: [",
            "        {",
            "            name: '${2:MyAgent}',",
            "            type: '${3:conversational}',",
            "            aiProvider: {",
            "                name: '${4:openai}',",
            "                model: '${5:gpt-4o}',",
            "                temperature: ${6:0.7}",
            "            },",
            "            emotionalStates: [",
            "                { name: '${7:joy}', defaultIntensity: ${8:0.7} },",
            "                { name: '${9:empathy}', defaultIntensity: ${10:0.9} }",
            "            ],",
            "            personality: {",
            "                traits: [${11:'helpful', 'creative'}],",
            "                communicationStyle: '${12:conversational}'",
            "            },",
            "            memoryProvider: {",
            "                type: '${13:sqlite}',",
            "                persistentMemory: ${14:true},",
            "                contextWindow: ${15:10}",
            "            }",
            "        }",
            "    ],",
            "    ",
            "    platforms: [",
            "        {",
            "            name: '${16:web}',",
            "            enabled: ${17:true},",
            "            port: ${18:3000}",
            "        }",
            "    ]",
            "};",
            "",
            "export default config;"
        ],
        "description": "Complete SYMindX configuration setup"
    },
    "SYMindX Context Provider": {
        "prefix": "symindx-context",
        "body": [
            "import { ContextProvider } from '@symbaex/symindx';",
            "",
            "const contextProvider = new ContextProvider({",
            "    enableEmotionalContext: ${1:true},",
            "    enableMemoryContext: ${2:true},",
            "    enableEnvironmentContext: ${3:true},",
            "    customContexts: [",
            "        {",
            "            name: '${4:userPreferences}',",
            "            provider: async (userId: string) => {",
            "                ${5:// Fetch user preferences from database}",
            "                return await ${6:getUserPreferences}(userId);",
            "            }",
            "        }",
            "    ]",
            "});",
            "",
            "async function ${7:getEnhancedContext}(userId: string, message: string) {",
            "    return await contextProvider.getContext({",
            "        userId,",
            "        currentMessage: message,",
            "        includeEmotionalState: true,",
            "        includeHistory: true,",
            "        includeCustomContexts: [${8:'userPreferences'}]",
            "    });",
            "}"
        ],
        "description": "Create enhanced context provider for SYMindX agents"
    },
    "SYMindX Extension": {
        "prefix": "symindx-extension",
        "body": [
            "import { Extension, Agent, ExtensionContext } from '@symbaex/symindx';",
            "",
            "export class ${1:CustomExtension} extends Extension {",
            "    name = '${2:custom-extension}';",
            "    version = '${3:1.0.0}';",
            "    description = '${4:A custom extension for enhanced functionality}';",
            "",
            "    async onLoad(context: ExtensionContext): Promise<void> {",
            "        console.log(`Loading ${this.name} extension...`);",
            "        ${5:// Initialize extension resources}",
            "    }",
            "",
            "    async onMessage(agent: Agent, message: string, userId: string): Promise<string | null> {",
            "        if (${6:this.shouldHandle}(message)) {",
            "            ${7:// Process the message with extension logic}",
            "            return await ${8:this.processMessage}(message, userId);",
            "        }",
            "        return null;",
            "    }",
            "",
            "    async onEmotionalStateChange(agent: Agent, oldState: any, newState: any): Promise<void> {",
            "        ${9:// React to emotional state changes}",
            "        console.log(`Emotional state changed from ${oldState} to ${newState}`);",
            "    }",
            "",
            "    private ${6:shouldHandle}(message: string): boolean {",
            "        return message.includes('${10:trigger-word}');",
            "    }",
            "",
            "    private async ${8:processMessage}(message: string, userId: string): Promise<string> {",
            "        ${11:// Implement custom message processing}",
            "        return `Processed by ${this.name}: ${message}`;",
            "    }",
            "}"
        ],
        "description": "Create a custom SYMindX extension"
    },
    "LangGraph Workflow": {
        "prefix": "langgraph-workflow",
        "body": [
            "import { StateGraph, MessagesAnnotation, START, END } from '@langchain/langgraph';",
            "import { ChatOpenAI } from '@langchain/openai';",
            "import { AIMessage } from '@langchain/core/messages';",
            "import { ToolNode } from '@langchain/langgraph/prebuilt';",
            "",
            "// Define your tools",
            "const tools = [${1:/* your tools here */}];",
            "const toolNode = new ToolNode(tools);",
            "const model = new ChatOpenAI({ model: '${2:gpt-4o}' }).bindTools(tools);",
            "",
            "// Define the routing logic",
            "function shouldContinue(state: typeof MessagesAnnotation.State) {",
            "    const { messages } = state;",
            "    const lastMessage = messages[messages.length - 1] as AIMessage;",
            "    ",
            "    // If no tools are called, we can finish",
            "    if (!lastMessage?.tool_calls?.length) {",
            "        return END;",
            "    }",
            "    // Otherwise continue to tools",
            "    return 'tools';",
            "}",
            "",
            "// Define the agent node",
            "async function callModel(state: typeof MessagesAnnotation.State) {",
            "    const { messages } = state;",
            "    const response = await model.invoke(messages);",
            "    return { messages: [response] };",
            "}",
            "",
            "// Build the workflow",
            "const workflow = new StateGraph(MessagesAnnotation)",
            "    .addNode('agent', callModel)",
            "    .addNode('tools', toolNode)",
            "    .addEdge(START, 'agent')",
            "    .addConditionalEdges('agent', shouldContinue, {",
            "        tools: 'tools',",
            "        [END]: END",
            "    })",
            "    .addEdge('tools', 'agent');",
            "",
            "const app = workflow.compile();",
            "",
            "// Usage",
            "const result = await app.invoke({",
            "    messages: [{ role: 'user', content: '${3:Your message here}' }]",
            "});"
        ],
        "description": "Create a LangGraph workflow with tool support (July 2025)"
    },
    "Vercel AI SDK Agent": {
        "prefix": "vercel-ai-agent",
        "body": [
            "import { openai } from '@ai-sdk/openai';",
            "import { generateText, tool, stepCountIs } from 'ai';",
            "import { z } from 'zod';",
            "",
            "// Define tools",
            "const ${1:weatherTool} = tool({",
            "    description: '${2:Get the weather in a location}',",
            "    inputSchema: z.object({",
            "        ${3:location}: z.string().describe('${4:The location to get the weather for}')",
            "    }),",
            "    execute: async ({ ${3:location} }) => ({",
            "        ${3:location},",
            "        temperature: 72 + Math.floor(Math.random() * 21) - 10",
            "    })",
            "});",
            "",
            "// Create agent function",
            "async function ${5:myAgent}(prompt: string) {",
            "    const result = await generateText({",
            "        model: openai('${6:gpt-4o}'),",
            "        tools: {",
            "            ${1:weatherTool}: ${1:weatherTool}",
            "        },",
            "        stopWhen: stepCountIs(${7:5}),",
            "        system: '${8:You are a helpful assistant. Think step by step.}',",
            "        prompt: prompt",
            "    });",
            "    ",
            "    return result;",
            "}",
            "",
            "// Usage",
            "const response = await ${5:myAgent}('${9:What is the weather in San Francisco?}');",
            "console.log(response.text);"
        ],
        "description": "Create a Vercel AI SDK 5 agent with tools and step control (July 2025)"
    },
    "OpenAI Realtime Agent": {
        "prefix": "openai-realtime",
        "body": [
            "import { RealtimeAgent, RealtimeSession, tool } from '@openai/agents-realtime';",
            "import { z } from 'zod';",
            "",
            "const ${1:weatherTool} = tool({",
            "    name: '${2:get_weather}',",
            "    description: '${3:Get the weather for a given city}',",
            "    parameters: z.object({ ",
            "        ${4:city}: z.string() ",
            "    }),",
            "    execute: async (input) => {",
            "        return `The weather in \${input.${4:city}} is sunny`;",
            "    },",
            "});",
            "",
            "const agent = new RealtimeAgent({",
            "    name: '${5:VoiceAgent}',",
            "    instructions: '${6:You are a helpful voice assistant}',",
            "    tools: [${1:weatherTool}],",
            "});",
            "",
            "// For browser environments",
            "const { apiKey } = await fetch('/path/to/ephemeral/key/generation').then(",
            "    (resp) => resp.json(),",
            ");",
            "",
            "// Automatically configures audio input/output",
            "const session = new RealtimeSession(agent);",
            "await session.connect({ apiKey });"
        ],
        "description": "Create a real-time voice agent with tools for browser applications (July 2025)"
    },
    "ElizaOS Character": {
        "prefix": "eliza-character",
        "body": [
            "import { Character } from '@elizaos/core';",
            "",
            "export const character: Character = {",
            "    name: '${1:MyAgent}',",
            "    description: '${2:A helpful AI assistant}',",
            "    plugins: [",
            "        '@elizaos/plugin-bootstrap',",
            "        '@elizaos/plugin-sql',",
            "        ...(!process.env.IGNORE_BOOTSTRAP ? ['@elizaos/plugin-bootstrap'] : []),",
            "        ...(process.env.DISCORD_API_TOKEN ? ['@elizaos/plugin-discord'] : []),",
            "        ...(process.env.OPENAI_API_KEY ? ['@elizaos/plugin-openai'] : [])",
            "    ],",
            "    settings: {",
            "        secrets: {},",
            "        avatar: '${3:https://example.com/avatar.png}'",
            "    },",
            "    system: '${4:Respond to all messages in a helpful, conversational manner...}',",
            "    bio: [",
            "        '${5:Engages with all types of questions and conversations}',",
            "        '${6:Provides helpful, concise responses}'",
            "    ],",
            "    topics: ['${7:general knowledge}', '${8:problem solving}', '${9:technology}'],",
            "    messageExamples: [",
            "        [",
            "            {",
            "                name: '{{user}}',",
            "                content: { text: '${10:Can you help me debug this?}' }",
            "            },",
            "            {",
            "                name: '${1:MyAgent}',",
            "                content: { text: '${11:I\\'d be happy to help! Can you share the error message?}' }",
            "            }",
            "        ]",
            "    ],",
            "    style: {",
            "        all: ['${12:Keep responses concise}', '${13:Use clear language}'],",
            "        chat: ['${14:Be conversational}', '${15:Show personality}']",
            "    }",
            "};"
        ],
        "description": "Create a complete ElizaOS character configuration (July 2025)"
    },
    "Vercel AI Streaming": {
        "prefix": "vercel-ai-stream",
        "body": [
            "import { openai } from '@ai-sdk/openai';",
            "import { streamText, tool } from 'ai';",
            "import { z } from 'zod';",
            "",
            "// Define a tool with streaming callbacks",
            "const ${1:searchTool} = tool({",
            "    description: '${2:Search for information}',",
            "    inputSchema: z.object({",
            "        ${3:query}: z.string()",
            "    }),",
            "    onInputStart: ({ toolCallId }) => {",
            "        console.log('Tool input streaming started:', toolCallId);",
            "    },",
            "    onInputDelta: ({ inputTextDelta }) => {",
            "        console.log('Tool input delta:', inputTextDelta);",
            "    },",
            "    onInputAvailable: ({ input }) => {",
            "        console.log('Tool input ready:', input);",
            "    },",
            "    execute: async ({ ${3:query} }) => {",
            "        // Implement search logic",
            "        return `Results for \${${3:query}}`;",
            "    }",
            "});",
            "",
            "// Stream with tools",
            "async function* streamWithTools(prompt: string) {",
            "    const result = await streamText({",
            "        model: openai('${4:gpt-4o}'),",
            "        tools: { ${1:searchTool} },",
            "        messages: [{ role: 'user', content: prompt }],",
            "        onStepFinish({ text, toolCalls, toolResults, finishReason, usage }) {",
            "            // Handle step completion",
            "            console.log('Step finished:', { text, toolCalls });",
            "        }",
            "    });",
            "    ",
            "    for await (const delta of result.textStream) {",
            "        yield delta;",
            "    }",
            "}",
            "",
            "// Usage",
            "for await (const chunk of streamWithTools('${5:Search for AI news}')) {",
            "    process.stdout.write(chunk);",
            "}"
        ],
        "description": "Create streaming responses with tool support and callbacks (July 2025)"
    },
    "CrewAI Agent": {
        "prefix": "crewai-agent",
        "body": [
            "// CrewAI TypeScript/JavaScript usage",
            "// Note: CrewAI is primarily Python-based. Consider using it via API or subprocess",
            "",
            "import { spawn } from 'child_process';",
            "",
            "const runCrewAI = async (task: string): Promise<string> => {",
            "    return new Promise((resolve, reject) => {",
            "        const pythonProcess = spawn('python', ['-c', `",
            "from crewai import Agent, Task, Crew",
            "from langchain_openai import ChatOpenAI",
            "",
            "${1:agent} = Agent(",
            "    role='${2:Researcher}',",
            "    goal='${3:Research and analyze information}',",
            "    backstory='${4:Expert researcher with analytical skills}',",
            "    llm=ChatOpenAI(model='${5:gpt-4o}')",
            ")",
            "",
            "task = Task(",
            "    description='${task}',",
            "    expected_output='${6:Detailed analysis report}',",
            "    agent=${1:agent}",
            ")",
            "",
            "crew = Crew(agents=[${1:agent}], tasks=[task])",
            "result = crew.kickoff()",
            "print(result)",
            "        `]);",
            "",
            "        let output = '';",
            "        pythonProcess.stdout.on('data', (data) => {",
            "            output += data.toString();",
            "        });",
            "",
            "        pythonProcess.on('close', (code) => {",
            "            if (code === 0) resolve(output);",
            "            else reject(new Error(`Process exited with code ${code}`));",
            "        });",
            "    });",
            "};"
        ],
        "description": "Run CrewAI from TypeScript/JavaScript (July 2025)"
    },
    "AutoGen TypeScript Bridge": {
        "prefix": "autogen-bridge",
        "body": [
            "// AutoGen TypeScript Bridge - Run AutoGen Python code from TS/JS",
            "import { spawn } from 'child_process';",
            "",
            "interface AutoGenConfig {",
            "    model: string;",
            "    temperature?: number;",
            "    maxTurns?: number;",
            "}",
            "",
            "class AutoGenBridge {",
            "    async runGroupChat(task: string, config: AutoGenConfig): Promise<string> {",
            "        const pythonCode = `",
            "import asyncio",
            "from autogen_agentchat.agents import AssistantAgent",
            "from autogen_agentchat.teams import RoundRobinGroupChat",
            "from autogen_agentchat.conditions import TextMentionTermination",
            "from autogen_ext.models.openai import OpenAIChatCompletionClient",
            "",
            "async def main():",
            "    model_client = OpenAIChatCompletionClient(model='${config.model}')",
            "    ",
            "    ${1:agent1} = AssistantAgent(",
            "        name='${2:Agent1}',",
            "        system_message='${3:First agent instructions}',",
            "        model_client=model_client",
            "    )",
            "    ",
            "    ${4:agent2} = AssistantAgent(",
            "        name='${5:Agent2}',",
            "        system_message='${6:Second agent instructions}',",
            "        model_client=model_client",
            "    )",
            "    ",
            "    termination = TextMentionTermination('TERMINATE')",
            "    group_chat = RoundRobinGroupChat(",
            "        [${1:agent1}, ${4:agent2}],",
            "        termination_condition=termination,",
            "        max_turns=${config.maxTurns || 10}",
            "    )",
            "    ",
            "    result = await group_chat.run(task='${task}')",
            "    print(result.messages[-1].content)",
            "    await model_client.close()",
            "",
            "asyncio.run(main())",
            "        `;",
            "",
            "        return this.executePython(pythonCode);",
            "    }",
            "",
            "    private executePython(code: string): Promise<string> {",
            "        return new Promise((resolve, reject) => {",
            "            const proc = spawn('python', ['-c', code]);",
            "            let output = '';",
            "            proc.stdout.on('data', (data) => output += data);",
            "            proc.on('close', (code) => {",
            "                if (code === 0) resolve(output);",
            "                else reject(new Error(`Python process exited with code ${code}`));",
            "            });",
            "        });",
            "    }",
            "}"
        ],
        "description": "Bridge to run AutoGen from TypeScript (July 2025)"
    }
}