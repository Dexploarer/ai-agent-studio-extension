{
    "LangGraph Basic Workflow": {
        "prefix": "langgraph-workflow",
        "body": [
            "from langgraph.graph import StateGraph, END",
            "from typing import TypedDict, Annotated, List",
            "import operator",
            "",
            "class ${1:WorkflowState}(TypedDict):",
            "    messages: Annotated[List[str], operator.add]",
            "    current_step: str",
            "    result: str",
            "",
            "class ${2:MyWorkflow}:",
            "    def __init__(self):",
            "        self.workflow = self._create_workflow()",
            "        self.app = self.workflow.compile()",
            "",
            "    def _create_workflow(self) -> StateGraph:",
            "        workflow = StateGraph(${1:WorkflowState})",
            "        ",
            "        # Add nodes",
            "        workflow.add_node('${3:process_input}', self.${3:process_input})",
            "        workflow.add_node('${4:execute_task}', self.${4:execute_task})",
            "        workflow.add_node('${5:format_result}', self.${5:format_result})",
            "        ",
            "        # Add edges",
            "        workflow.set_entry_point('${3:process_input}')",
            "        workflow.add_edge('${3:process_input}', '${4:execute_task}')",
            "        workflow.add_edge('${4:execute_task}', '${5:format_result}')",
            "        workflow.add_edge('${5:format_result}', END)",
            "        ",
            "        return workflow",
            "",
            "    def ${3:process_input}(self, state: ${1:WorkflowState}) -> ${1:WorkflowState}:",
            "        ${6:# Process input logic}",
            "        return {",
            "            'current_step': '${3:process_input}',",
            "            'result': ''",
            "        }",
            "",
            "    def ${4:execute_task}(self, state: ${1:WorkflowState}) -> ${1:WorkflowState}:",
            "        ${7:# Task execution logic}",
            "        return {",
            "            'current_step': '${4:execute_task}',",
            "            'result': '${8:Task completed}'",
            "        }",
            "",
            "    def ${5:format_result}(self, state: ${1:WorkflowState}) -> ${1:WorkflowState}:",
            "        ${9:# Result formatting logic}",
            "        return {",
            "            'current_step': '${5:format_result}',",
            "            'result': f\"Final: {state.get('result', '')}\"",
            "        }",
            "",
            "    def run(self, initial_messages: List[str]) -> ${1:WorkflowState}:",
            "        initial_state = {",
            "            'messages': initial_messages,",
            "            'current_step': '',",
            "            'result': ''",
            "        }",
            "        return self.app.invoke(initial_state)"
        ],
        "description": "Create a basic LangGraph workflow"
    },
    "CrewAI Agent": {
        "prefix": "crewai-agent",
        "body": [
            "from crewai import Agent",
            "",
            "${1:agent_name} = Agent(",
            "    role='${2:Specialist Role}',",
            "    goal='${3:Achieve specific objectives}',",
            "    backstory='${4:You are an expert with years of experience in your field}',",
            "    verbose=True,",
            "    allow_delegation=${5:False},",
            "    tools=[${6:# Add tools here}],",
            "    max_iter=${7:3},",
            "    memory=True",
            ")"
        ],
        "description": "Create a CrewAI agent"
    },
    "CrewAI Task": {
        "prefix": "crewai-task",
        "body": [
            "from crewai import Task",
            "",
            "${1:task_name} = Task(",
            "    description='${2:Detailed description of what needs to be accomplished}',",
            "    agent=${3:assigned_agent},",
            "    expected_output='${4:Description of expected output format and content}',",
            "    tools=[${5:# Optional: specific tools for this task}],",
            "    context=[${6:# Optional: context from other tasks}]",
            ")"
        ],
        "description": "Create a CrewAI task"
    },
    "CrewAI Crew": {
        "prefix": "crewai-crew",
        "body": [
            "from crewai import Crew, Process",
            "",
            "${1:crew_name} = Crew(",
            "    agents=[${2:agent1, agent2, agent3}],",
            "    tasks=[${3:task1, task2, task3}],",
            "    process=Process.${4|sequential,hierarchical|},",
            "    verbose=${5:2},",
            "    memory=${6:True}",
            ")",
            "",
            "# Execute the crew",
            "result = ${1:crew_name}.kickoff()"
        ],
        "description": "Create a CrewAI crew"
    },
    "AutoGen Conversable Agent": {
        "prefix": "autogen-agent",
        "body": [
            "import autogen",
            "",
            "${1:agent_name} = autogen.ConversableAgent(",
            "    name=\"${2:AgentName}\",",
            "    system_message=\"${3:You are a helpful AI assistant with specific expertise.}\",",
            "    llm_config={${4:\"config_list\": config_list, \"temperature\": 0.7}},",
            "    human_input_mode=\"${5|NEVER,TERMINATE,ALWAYS|}\",",
            "    max_consecutive_auto_reply=${6:10},",
            "    is_termination_msg=lambda x: x.get(\"content\", \"\").rstrip().endswith(\"TERMINATE\"),",
            ")"
        ],
        "description": "Create an AutoGen conversable agent"
    },
    "AutoGen Group Chat": {
        "prefix": "autogen-groupchat",
        "body": [
            "import autogen",
            "",
            "# Create group chat",
            "groupchat = autogen.GroupChat(",
            "    agents=[${1:agent1, agent2, agent3}],",
            "    messages=[],",
            "    max_round=${2:12},",
            "    speaker_selection_method=\"${3|round_robin,auto,manual|}\",",
            ")",
            "",
            "# Create manager",
            "manager = autogen.GroupChatManager(",
            "    groupchat=groupchat,",
            "    llm_config={${4:\"config_list\": config_list, \"temperature\": 0.5}},",
            ")",
            "",
            "# Start conversation",
            "${5:user_proxy}.initiate_chat(",
            "    manager,",
            "    message=\"${6:Initial message to start the conversation}\"",
            ")"
        ],
        "description": "Create an AutoGen group chat"
    },
    "SmolAgents Basic Setup": {
        "prefix": "smolagents-basic",
        "body": [
            "from smolagents import CodeAgent, LiteLLMModel",
            "from smolagents.tools import DuckDuckGoSearchTool, PythonInterpreterTool",
            "",
            "# Initialize model",
            "model = LiteLLMModel(model_id=\"${1:gpt-4o}\")",
            "",
            "# Initialize tools",
            "tools = [",
            "    ${2:DuckDuckGoSearchTool()},",
            "    ${3:PythonInterpreterTool()}",
            "]",
            "",
            "# Create agent",
            "agent = CodeAgent(",
            "    tools=tools,",
            "    model=model,",
            "    max_steps=${4:10},",
            "    verbose=${5:True}",
            ")",
            "",
            "# Run task",
            "result = agent.run(\"${6:Your task description here}\")"
        ],
        "description": "Create a basic SmolAgents setup"
    },
    "Pydantic AI Agent": {
        "prefix": "pydantic-ai",
        "body": [
            "from pydantic_ai import Agent",
            "from pydantic import BaseModel",
            "",
            "class ${1:ResponseModel}(BaseModel):",
            "    result: str",
            "    confidence: float",
            "    category: str",
            "",
            "agent = Agent(",
            "    '${2:openai:gpt-4o}',",
            "    result_type=${1:ResponseModel},",
            "    system_prompt='${3:You are a helpful AI assistant that provides structured responses.}'",
            ")",
            "",
            "async def ${4:process_request}(message: str) -> ${1:ResponseModel}:",
            "    result = await agent.run(message)",
            "    return result"
        ],
        "description": "Create a Pydantic AI agent with type safety"
    },
    "Python Error Handling": {
        "prefix": "agent-error-handling",
        "body": [
            "try:",
            "    ${1:# Agent operation}",
            "    result = await ${2:agent.process}(${3:input})",
            "    return result",
            "except ${4:SpecificException} as e:",
            "    logger.error(f\"Specific error: {e}\")",
            "    return \"${5:Specific error response}\"",
            "except Exception as e:",
            "    logger.error(f\"${6:Agent error}: {e}\")",
            "    return \"${7:I apologize, but I encountered an error. Please try again.}\""
        ],
        "description": "Python error handling pattern for AI agents"
    },
    "Python Agent Config": {
        "prefix": "agent-config",
        "body": [
            "from dataclasses import dataclass",
            "from typing import List, Optional",
            "import os",
            "",
            "@dataclass",
            "class AgentConfig:",
            "    name: str = \"${1:MyAgent}\"",
            "    model: str = \"${2:gpt-4o}\"",
            "    temperature: float = ${3:0.7}",
            "    max_tokens: int = ${4:1000}",
            "    system_prompt: str = \"${5:You are a helpful AI assistant.}\"",
            "    tools: Optional[List[str]] = None",
            "    memory: bool = ${6:True}",
            "",
            "# Load from environment or use defaults",
            "config = AgentConfig(",
            "    name=os.getenv(\"AGENT_NAME\", \"${1:MyAgent}\"),",
            "    model=os.getenv(\"AGENT_MODEL\", \"${2:gpt-4o}\"),",
            "    temperature=float(os.getenv(\"AGENT_TEMPERATURE\", \"${3:0.7}\")),",
            "    # Add other config overrides as needed",
            ")"
        ],
        "description": "Python agent configuration with dataclass"
    }
}